"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fake = exports.perBuild = exports.sequence = exports.bool = exports.oneOf = exports.build = void 0;
const faker = __importStar(require("faker"));
const lodash_1 = require("lodash");
const isGenerator = (field) => {
    if (!field)
        return false;
    return field.generatorType !== undefined;
};
const identity = (x) => x;
const buildTimeTraitsArray = (buildTimeConfig) => {
    const { traits = [] } = buildTimeConfig;
    return Array.isArray(traits) ? traits : [traits];
};
const getValueOrOverride = (overrides, traitOverrides, fieldValue, fieldKey) => {
    if (Object.keys(overrides).includes(fieldKey)) {
        return overrides[fieldKey];
    }
    if (Object.keys(traitOverrides).includes(fieldKey)) {
        return traitOverrides[fieldKey];
    }
    return fieldValue;
};
const build = (factoryNameOrConfig, configObject) => {
    const config = (typeof factoryNameOrConfig === 'string' ? configObject : factoryNameOrConfig);
    let sequenceCounter = 0;
    const expandConfigFields = (fields, buildTimeConfig = {}) => {
        const finalBuiltThing = (0, lodash_1.mapValues)(fields, (fieldValue, fieldKey) => {
            const overrides = buildTimeConfig.overrides || {};
            const traitsArray = buildTimeTraitsArray(buildTimeConfig);
            const traitOverrides = traitsArray.reduce((overrides, currentTraitKey) => {
                const hasTrait = config.traits && config.traits[currentTraitKey];
                if (!hasTrait) {
                    console.warn(`Warning: trait '${currentTraitKey}' not found.`);
                }
                const traitsConfig = config.traits
                    ? config.traits[currentTraitKey]
                    : {};
                return Object.assign(Object.assign({}, overrides), (traitsConfig.overrides || {}));
            }, {});
            const valueOrOverride = getValueOrOverride(overrides, traitOverrides, fieldValue, fieldKey);
            /* eslint-disable-next-line @typescript-eslint/no-use-before-define */
            return expandConfigField(valueOrOverride);
        });
        return finalBuiltThing;
    };
    const expandConfigField = (fieldValue) => {
        let calculatedValue;
        if (isGenerator(fieldValue)) {
            switch (fieldValue.generatorType) {
                case 'sequence': {
                    ++sequenceCounter;
                    calculatedValue = fieldValue.call(fieldValue.userProvidedFunction, sequenceCounter);
                    break;
                }
                case 'faker': {
                    calculatedValue = fieldValue.call(faker);
                    break;
                }
                case 'oneOf': {
                    calculatedValue = fieldValue.call(fieldValue.options);
                    break;
                }
                case 'perBuild': {
                    calculatedValue = fieldValue.call(fieldValue.func);
                    break;
                }
            }
        }
        else if (Array.isArray(fieldValue)) {
            calculatedValue = fieldValue.map((v) => expandConfigField(v));
            return calculatedValue;
        }
        else if (fieldValue === null || fieldValue === undefined) {
            // has to be before typeof fieldValue === 'object'
            // as typeof null === 'object'
            calculatedValue = fieldValue;
        }
        else if (typeof fieldValue === 'object') {
            const nestedFieldsObject = fieldValue;
            calculatedValue = expandConfigFields(nestedFieldsObject);
        }
        else {
            calculatedValue = fieldValue;
        }
        return calculatedValue;
    };
    return (buildTimeConfig = {}) => {
        const fieldsToReturn = expandConfigFields(config.fields, buildTimeConfig);
        const traitsArray = buildTimeTraitsArray(buildTimeConfig);
        const traitPostBuilds = traitsArray.map((traitName) => {
            const traitConfig = (config.traits && config.traits[traitName]) || {};
            const postBuild = traitConfig.postBuild || identity;
            return postBuild;
        });
        const afterTraitPostBuildFields = traitPostBuilds.reduce((fields, traitPostBuild) => {
            return traitPostBuild(fields);
        }, fieldsToReturn);
        const postBuild = config.postBuild || identity;
        const buildTimeMapFunc = buildTimeConfig.map || identity;
        return buildTimeMapFunc(postBuild(afterTraitPostBuildFields));
    };
};
exports.build = build;
const oneOf = (...options) => {
    return {
        generatorType: 'oneOf',
        options,
        call: (options) => {
            const randomIndex = Math.floor(Math.random() * options.length);
            return options[randomIndex];
        },
    };
};
exports.oneOf = oneOf;
const bool = () => (0, exports.oneOf)(true, false);
exports.bool = bool;
const sequence = (userProvidedFunction = (x) => x) => {
    return {
        generatorType: 'sequence',
        userProvidedFunction,
        call: (userProvidedFunction, counter) => {
            return userProvidedFunction(counter);
        },
    };
};
exports.sequence = sequence;
const perBuild = (func) => {
    return {
        generatorType: 'perBuild',
        func,
        call: (f) => {
            return f();
        },
    };
};
exports.perBuild = perBuild;
const fake = (userDefinedUsage) => {
    return {
        generatorType: 'faker',
        call: (faker) => {
            return userDefinedUsage(faker);
        },
    };
};
exports.fake = fake;
//# sourceMappingURL=index.js.map